<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>livemelee.interact API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livemelee.interact</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import threading
import argparse
import signal
from . import utils

BREAK_FLAG = -2
EXTRA_ARGS = &#39;extra_args&#39;
# CONTINUOUS_FLAG = &#39;continuous&#39;

class LiveInputsThread(threading.Thread):
    &#39;&#39;&#39;Invoke functions in a shell session during gameplay.
    Similar to a command line parser but streamlined experience, no flags.
    Used for live debugging or injecting commands to gameplay.
    Commands should not print anything themselves - just return string/data, if anything.

    Commands format: `{&#39;cmd&#39;: func}` or better `{&#39;cmd&#39;: (func, &#39;descrip/directions&#39;)}`

    Ex:
    ```
    live_thread = LiveInputsThread(         # init before starting game
        onshutdown=stop_everything,
        commands={
            &#39;status&#39;: lambda: bot.status,
            &#39;connect&#39;: (bot.direct_connect, &#39;direct connect to [code]&#39;),
            &#39;A&#39;: controller.press_a,
            &#39;moveto&#39;: (bot.move, &#39;move bot to [x] [y] coords&#39;),
            &#39;seq&#39;: (bot.loop_inputs, &#39;repeat inputs [a/b/x/y/l/r/z] [up/down/left/right] [release] [n wait]&#39;),
        })
    ```
    &gt;&gt;&gt; [...this thread is waiting and game loop is started...]
    &gt;&gt;&gt; connect PLUP#123
    &gt;&gt;&gt; moveto 10 40
    &gt;&gt;&gt; status
    &gt;&gt;&gt;   Bot status: ...
    &gt;&gt;&gt; seq b down 3 y release
    &gt;&gt;&gt; quit&#39;&#39;&#39;

    def __init__(self, onshutdown=lambda:None, commands={}):
        &#39;&#39;&#39;Creates parser with given commands and starts thread awaiting input.&#39;&#39;&#39;
        parser = argparse.ArgumentParser(prog=&#39;&#39;,           # program name would distract
                                         description=&#39;Perform commands during gameplay.&#39;,
                                         add_help=False)    # we have custom help arg, not &#34;-help&#34;
        meta_commands = {
            &#39;test&#39;: (lambda *s:&#39;You typed {} arg(s): {}&#39;.format(len(s), s), &#39;test [extra] [args] ...&#39;),
            &#39;help&#39;: parser.print_help,  # ideally help and quit dont get wrapped in _print and _accept_args
            &#39;quit&#39;: lambda: BREAK_FLAG  #   when it happens in _add_commands
        }                               #   but oh well

        subparser_adder = parser.add_subparsers()
        for command, details in {**commands, **meta_commands}.items():
            _add_command(subparser_adder, command, details)
            # type(self)._add_command(subparser_adder, command, details)   # allow subclassing?

        self.parser = parser
        self.onshutdown = onshutdown    # callable
        # signal.signal(signal.SIGINT, lambda sig, frame: self.shutdown)  # ctrl-c interrupt

        super().__init__(name=&#39;input-thread&#39;)
        # self.start()    # maybe save for caller to start when they want?

    def run(self):
        &#39;&#39;&#39;Start this thread waiting for user inputs, exiting program if asked.&#39;&#39;&#39;
        self.parser.print_help()

        while True: # wait for next input
            try:
                args = self.parser.parse_args(args=_separate(input()))
                # perform command
                if args.func(args) == BREAK_FLAG:
                    print(&#39;Stopping thread...&#39;)
                    break

            except SystemExit as e: # thrown whenever parser doesn&#39;t like input
                # print(&#39;Bad command:&#39;, e)
                continue
            except TypeError as e:  # probably from bad command args, eg. &gt;&gt;&gt; help something
                print(&#39;Bad command extra args:&#39;, e)
                continue
            # thrown when ctrl-c interrupts hanging input() -
            # except (KeyboardInterrupt, EOFError, Exception) as e:
            #     break

        self.onshutdown()

    def update(self, gamestate):
        &#39;&#39;&#39;Override this if you want to check something each frame.&#39;&#39;&#39;
        pass

###  helpers for LiveInputsThread

class _StoreExtraArgs(argparse.Action):
    &#39;&#39;&#39;This action allows inputs like:
    &gt;&gt;&gt; connect PLUP#123 or &gt;&gt;&gt; moveto 10 40
    as opposed to default parser behavior:
    &gt;&gt;&gt; connect -specific_flag PLUP#123 or &gt;&gt;&gt; moveto -other_flag 10 40

    Extra args will later be passed to command as positional args
    eg. &gt;&gt;&gt; cmd a b 10   -&gt;   func_for_cmd(&#39;a&#39;,&#39;b&#39;,&#39;10&#39;)
    Quirks/drawbacks to this style/implementation:
      - no kwargs allowed (too messy to implement anyways); only positional args.
      - args can&#39;t start with &#34;-&#34; (RIP negatives) (it triggers parser unrecognized flag)
      - args come from string (raw user input separated on spaces),
      so command functions taking these args need to parse strs (eg str -&gt; int)
      - no helpful parser checking/catching/help messages on error for these extra args
      (throws type errors or other) (as opposed to intended parser usage giving help)&#39;&#39;&#39;

    def __init__(self, **kwargs):
        kwargs[&#39;nargs&#39;] = &#39;*&#39;   # accept 0 or more args
        super().__init__(**kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, EXTRA_ARGS, values)

def _add_command(subparser_adder, command, details):
    &#39;&#39;&#39;Adds command as subparser/subcommand sharing first input position.
    Subcommands won&#39;t need &#34;-&#34; option symbol.&#39;&#39;&#39;

    func, descrip = _unpack(details)
    cmd_parser = subparser_adder.add_parser(command,
                                            help=descrip,
                                            add_help=False)
    cmd_parser.set_defaults(func=_print(_accept_any_args(func)))    # set the command
    cmd_parser.add_argument(EXTRA_ARGS, action=_StoreExtraArgs)  # allow any extra inputs as args

def _accept_any_args(func):
    # wrapper for taking any args that were parsed
    return lambda args_namespace: func(*getattr(args_namespace, EXTRA_ARGS))#, default=[]))

def _unpack(details):
    # completes (func, descrip) if descrip not present in details tuple.
    # covers short command {cmd: func} in commands dict.
    # doesnt technically unpack here but it sounds nice when used in context.
    return (details if type(details) is tuple else (details, &#39;&#39;))

def _print(func):
    # wrapper for printing before returning result of a function.
    def f(*args):
        result = func(*args)
        if result == None:   # printing None does not look nice
            print(&#39;.&#39;)#done&#39;)# assure that function finished (or should we do nothing?)
        else:
            print(result)
        return result
    return f

def _separate(s):
    # emulating sys.argv with raw input string. currently ignores quotes wrapping spaces.
    return s.split(&#39; &#39;)

### extending LiveInputsThread with more features

class LiveGameStats(LiveInputsThread):
    &#39;&#39;&#39;Enhances LiveInputsThread by incorporating stats from melee.GameState
    and adding stat-tracking / printing-on-change feature.

    &gt;&gt;&gt; track p
    &gt;&gt;&gt; Percents: 0%  0%
    &gt;&gt;&gt; Percents: 3%  0%
    &gt;&gt;&gt; Percents: 3%  16%
    &gt;&gt;&gt; notrack
    &gt;&gt;&gt; .
    &gt;&gt;&gt; a
    &gt;&gt;&gt; Action states: Action.CROUCHING  Action.LANDING&#39;&#39;&#39;

    def __init__(self, onshutdown=lambda:None, commands={}):

        stats = {cmd: ( self._with_gamestate(func), descrip )
             for cmd, (func, descrip) in {
                &#39;f&#39;: (utils.frame_num, &#39;frame num&#39;),
                &#39;p&#39;: (utils.percents, &#39;percents&#39;),
                &#39;d&#39;: (utils.distance, &#39;distance&#39;),
                &#39;a&#39;: (utils.actions, &#39;action states&#39;),
                &#39;g&#39;: (utils.gamestate, &#39;gamestate&#39;),
                &#39;m&#39;: (utils.menu, &#39;menu&#39;),
                &#39;stocks&#39;: (utils.stocks, &#39;stocks&#39;),
             }.items()
        }
        stats.update({   # don&#39;t need gamestate
            &#39;dur&#39;: (self._stock_duration, &#39;this stock duration&#39;),
            &#39;track&#39;: (self._track, &#39;print [cmd] when it updates&#39;),
            &#39;no&#39;: (self._reset_tracker, &#39;stop tracking&#39;),
        })
        commands.update(stats)
        self.commands = commands
        super().__init__(onshutdown=onshutdown, commands=commands)

        # any persistent/cumulative stats
        self._stock_duration = 0     # frames
        self._stocks = 4             # tells when to reset above
        self._last_gamestate = None  # will provide rest of the stats

        self._tracker = None        # callable, called each frame
        self._tracked_last = None   # from above

    def _with_gamestate(self, func):
        # wrapper to pass last gamestate stored in self
        return lambda: func(self._last_gamestate)

    def update(self, gamestate):
        &#39;&#39;&#39;Call this each frame with new gamestate to update recent stats.&#39;&#39;&#39;
        self._last_gamestate = gamestate

        # update any cumulative stats
        if utils.in_game(gamestate):   # game started
            self._update_stock_dur(gamestate)

        if self._tracker:
            curr = self._tracker()
            if not curr == self._tracked_last:
                self._tracked_last = curr
                print(curr)

    def _track(self, cmd):
        # check cmd func each frame for change. func must takes 0 args.
        # if custom func needs gamestate, consider wrapping _with_gamestate(func)?
        func, _ = _unpack(self.commands[cmd])
        self._tracker = func

    def _reset_tracker(self):
        self._tracker = None
        self._tracked_last = None

    # for specific stats

    def _stock_duration(self):
        # a cumulative stat stored in self
        return &#39;{} sec into this stock&#39;.format(self._stock_duration // 60)   # 60 fps

    def _update_stock_dur(self, gamestate):
        curr_stocks = gamestate.player[2].stock
        if not self._stocks == curr_stocks: # reset on new stock
            self._stocks = curr_stocks      # -= 1
            self._stock_duration = 0
        else:                               # add another 1/60th sec
            self._stock_duration += 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livemelee.interact.LiveGameStats"><code class="flex name class">
<span>class <span class="ident">LiveGameStats</span></span>
<span>(</span><span>onshutdown=&lt;function LiveGameStats.&lt;lambda&gt;&gt;, commands={&#x27;f&#x27;: (&lt;function LiveGameStats._with_gamestate.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;frame num&#x27;), &#x27;p&#x27;: (&lt;function LiveGameStats._with_gamestate.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;percents&#x27;), &#x27;d&#x27;: (&lt;function LiveGameStats._with_gamestate.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;distance&#x27;), &#x27;a&#x27;: (&lt;function LiveGameStats._with_gamestate.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;action states&#x27;), &#x27;g&#x27;: (&lt;function LiveGameStats._with_gamestate.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;gamestate&#x27;), &#x27;m&#x27;: (&lt;function LiveGameStats._with_gamestate.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;menu&#x27;), &#x27;stocks&#x27;: (&lt;function LiveGameStats._with_gamestate.&lt;locals&gt;.&lt;lambda&gt;&gt;, &#x27;stocks&#x27;), &#x27;dur&#x27;: (&lt;bound method LiveGameStats._stock_duration of &lt;LiveGameStats(input-thread, initial)&gt;&gt;, &#x27;this stock duration&#x27;), &#x27;track&#x27;: (&lt;bound method LiveGameStats._track of &lt;LiveGameStats(input-thread, initial)&gt;&gt;, &#x27;print [cmd] when it updates&#x27;), &#x27;no&#x27;: (&lt;bound method LiveGameStats._reset_tracker of &lt;LiveGameStats(input-thread, initial)&gt;&gt;, &#x27;stop tracking&#x27;)})</span>
</code></dt>
<dd>
<div class="desc"><p>Enhances LiveInputsThread by incorporating stats from melee.GameState
and adding stat-tracking / printing-on-change feature.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; track p
&gt;&gt;&gt; Percents: 0%  0%
&gt;&gt;&gt; Percents: 3%  0%
&gt;&gt;&gt; Percents: 3%  16%
&gt;&gt;&gt; notrack
&gt;&gt;&gt; .
&gt;&gt;&gt; a
&gt;&gt;&gt; Action states: Action.CROUCHING  Action.LANDING
</code></pre>
<p>Creates parser with given commands and starts thread awaiting input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LiveGameStats(LiveInputsThread):
    &#39;&#39;&#39;Enhances LiveInputsThread by incorporating stats from melee.GameState
    and adding stat-tracking / printing-on-change feature.

    &gt;&gt;&gt; track p
    &gt;&gt;&gt; Percents: 0%  0%
    &gt;&gt;&gt; Percents: 3%  0%
    &gt;&gt;&gt; Percents: 3%  16%
    &gt;&gt;&gt; notrack
    &gt;&gt;&gt; .
    &gt;&gt;&gt; a
    &gt;&gt;&gt; Action states: Action.CROUCHING  Action.LANDING&#39;&#39;&#39;

    def __init__(self, onshutdown=lambda:None, commands={}):

        stats = {cmd: ( self._with_gamestate(func), descrip )
             for cmd, (func, descrip) in {
                &#39;f&#39;: (utils.frame_num, &#39;frame num&#39;),
                &#39;p&#39;: (utils.percents, &#39;percents&#39;),
                &#39;d&#39;: (utils.distance, &#39;distance&#39;),
                &#39;a&#39;: (utils.actions, &#39;action states&#39;),
                &#39;g&#39;: (utils.gamestate, &#39;gamestate&#39;),
                &#39;m&#39;: (utils.menu, &#39;menu&#39;),
                &#39;stocks&#39;: (utils.stocks, &#39;stocks&#39;),
             }.items()
        }
        stats.update({   # don&#39;t need gamestate
            &#39;dur&#39;: (self._stock_duration, &#39;this stock duration&#39;),
            &#39;track&#39;: (self._track, &#39;print [cmd] when it updates&#39;),
            &#39;no&#39;: (self._reset_tracker, &#39;stop tracking&#39;),
        })
        commands.update(stats)
        self.commands = commands
        super().__init__(onshutdown=onshutdown, commands=commands)

        # any persistent/cumulative stats
        self._stock_duration = 0     # frames
        self._stocks = 4             # tells when to reset above
        self._last_gamestate = None  # will provide rest of the stats

        self._tracker = None        # callable, called each frame
        self._tracked_last = None   # from above

    def _with_gamestate(self, func):
        # wrapper to pass last gamestate stored in self
        return lambda: func(self._last_gamestate)

    def update(self, gamestate):
        &#39;&#39;&#39;Call this each frame with new gamestate to update recent stats.&#39;&#39;&#39;
        self._last_gamestate = gamestate

        # update any cumulative stats
        if utils.in_game(gamestate):   # game started
            self._update_stock_dur(gamestate)

        if self._tracker:
            curr = self._tracker()
            if not curr == self._tracked_last:
                self._tracked_last = curr
                print(curr)

    def _track(self, cmd):
        # check cmd func each frame for change. func must takes 0 args.
        # if custom func needs gamestate, consider wrapping _with_gamestate(func)?
        func, _ = _unpack(self.commands[cmd])
        self._tracker = func

    def _reset_tracker(self):
        self._tracker = None
        self._tracked_last = None

    # for specific stats

    def _stock_duration(self):
        # a cumulative stat stored in self
        return &#39;{} sec into this stock&#39;.format(self._stock_duration // 60)   # 60 fps

    def _update_stock_dur(self, gamestate):
        curr_stocks = gamestate.player[2].stock
        if not self._stocks == curr_stocks: # reset on new stock
            self._stocks = curr_stocks      # -= 1
            self._stock_duration = 0
        else:                               # add another 1/60th sec
            self._stock_duration += 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livemelee.interact.LiveInputsThread" href="#livemelee.interact.LiveInputsThread">LiveInputsThread</a></li>
<li>threading.Thread</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livemelee.interact.LiveGameStats.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"><p>Call this each frame with new gamestate to update recent stats.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, gamestate):
    &#39;&#39;&#39;Call this each frame with new gamestate to update recent stats.&#39;&#39;&#39;
    self._last_gamestate = gamestate

    # update any cumulative stats
    if utils.in_game(gamestate):   # game started
        self._update_stock_dur(gamestate)

    if self._tracker:
        curr = self._tracker()
        if not curr == self._tracked_last:
            self._tracked_last = curr
            print(curr)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livemelee.interact.LiveInputsThread" href="#livemelee.interact.LiveInputsThread">LiveInputsThread</a></b></code>:
<ul class="hlist">
<li><code><a title="livemelee.interact.LiveInputsThread.run" href="#livemelee.interact.LiveInputsThread.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livemelee.interact.LiveInputsThread"><code class="flex name class">
<span>class <span class="ident">LiveInputsThread</span></span>
<span>(</span><span>onshutdown=&lt;function LiveInputsThread.&lt;lambda&gt;&gt;, commands={})</span>
</code></dt>
<dd>
<div class="desc"><p>Invoke functions in a shell session during gameplay.
Similar to a command line parser but streamlined experience, no flags.
Used for live debugging or injecting commands to gameplay.
Commands should not print anything themselves - just return string/data, if anything.</p>
<p>Commands format: <code>{'cmd': func}</code> or better <code>{'cmd': (func, 'descrip/directions')}</code></p>
<p>Ex:</p>
<pre><code>live_thread = LiveInputsThread(         # init before starting game
    onshutdown=stop_everything,
    commands={
        'status': lambda: bot.status,
        'connect': (bot.direct_connect, 'direct connect to [code]'),
        'A': controller.press_a,
        'moveto': (bot.move, 'move bot to [x] [y] coords'),
        'seq': (bot.loop_inputs, 'repeat inputs [a/b/x/y/l/r/z] [up/down/left/right] [release] [n wait]'),
    })
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; [...this thread is waiting and game loop is started...]
&gt;&gt;&gt; connect PLUP#123
&gt;&gt;&gt; moveto 10 40
&gt;&gt;&gt; status
&gt;&gt;&gt;   Bot status: ...
&gt;&gt;&gt; seq b down 3 y release
&gt;&gt;&gt; quit
</code></pre>
<p>Creates parser with given commands and starts thread awaiting input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LiveInputsThread(threading.Thread):
    &#39;&#39;&#39;Invoke functions in a shell session during gameplay.
    Similar to a command line parser but streamlined experience, no flags.
    Used for live debugging or injecting commands to gameplay.
    Commands should not print anything themselves - just return string/data, if anything.

    Commands format: `{&#39;cmd&#39;: func}` or better `{&#39;cmd&#39;: (func, &#39;descrip/directions&#39;)}`

    Ex:
    ```
    live_thread = LiveInputsThread(         # init before starting game
        onshutdown=stop_everything,
        commands={
            &#39;status&#39;: lambda: bot.status,
            &#39;connect&#39;: (bot.direct_connect, &#39;direct connect to [code]&#39;),
            &#39;A&#39;: controller.press_a,
            &#39;moveto&#39;: (bot.move, &#39;move bot to [x] [y] coords&#39;),
            &#39;seq&#39;: (bot.loop_inputs, &#39;repeat inputs [a/b/x/y/l/r/z] [up/down/left/right] [release] [n wait]&#39;),
        })
    ```
    &gt;&gt;&gt; [...this thread is waiting and game loop is started...]
    &gt;&gt;&gt; connect PLUP#123
    &gt;&gt;&gt; moveto 10 40
    &gt;&gt;&gt; status
    &gt;&gt;&gt;   Bot status: ...
    &gt;&gt;&gt; seq b down 3 y release
    &gt;&gt;&gt; quit&#39;&#39;&#39;

    def __init__(self, onshutdown=lambda:None, commands={}):
        &#39;&#39;&#39;Creates parser with given commands and starts thread awaiting input.&#39;&#39;&#39;
        parser = argparse.ArgumentParser(prog=&#39;&#39;,           # program name would distract
                                         description=&#39;Perform commands during gameplay.&#39;,
                                         add_help=False)    # we have custom help arg, not &#34;-help&#34;
        meta_commands = {
            &#39;test&#39;: (lambda *s:&#39;You typed {} arg(s): {}&#39;.format(len(s), s), &#39;test [extra] [args] ...&#39;),
            &#39;help&#39;: parser.print_help,  # ideally help and quit dont get wrapped in _print and _accept_args
            &#39;quit&#39;: lambda: BREAK_FLAG  #   when it happens in _add_commands
        }                               #   but oh well

        subparser_adder = parser.add_subparsers()
        for command, details in {**commands, **meta_commands}.items():
            _add_command(subparser_adder, command, details)
            # type(self)._add_command(subparser_adder, command, details)   # allow subclassing?

        self.parser = parser
        self.onshutdown = onshutdown    # callable
        # signal.signal(signal.SIGINT, lambda sig, frame: self.shutdown)  # ctrl-c interrupt

        super().__init__(name=&#39;input-thread&#39;)
        # self.start()    # maybe save for caller to start when they want?

    def run(self):
        &#39;&#39;&#39;Start this thread waiting for user inputs, exiting program if asked.&#39;&#39;&#39;
        self.parser.print_help()

        while True: # wait for next input
            try:
                args = self.parser.parse_args(args=_separate(input()))
                # perform command
                if args.func(args) == BREAK_FLAG:
                    print(&#39;Stopping thread...&#39;)
                    break

            except SystemExit as e: # thrown whenever parser doesn&#39;t like input
                # print(&#39;Bad command:&#39;, e)
                continue
            except TypeError as e:  # probably from bad command args, eg. &gt;&gt;&gt; help something
                print(&#39;Bad command extra args:&#39;, e)
                continue
            # thrown when ctrl-c interrupts hanging input() -
            # except (KeyboardInterrupt, EOFError, Exception) as e:
            #     break

        self.onshutdown()

    def update(self, gamestate):
        &#39;&#39;&#39;Override this if you want to check something each frame.&#39;&#39;&#39;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>threading.Thread</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livemelee.interact.LiveGameStats" href="#livemelee.interact.LiveGameStats">LiveGameStats</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livemelee.interact.LiveInputsThread.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start this thread waiting for user inputs, exiting program if asked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#39;&#39;&#39;Start this thread waiting for user inputs, exiting program if asked.&#39;&#39;&#39;
    self.parser.print_help()

    while True: # wait for next input
        try:
            args = self.parser.parse_args(args=_separate(input()))
            # perform command
            if args.func(args) == BREAK_FLAG:
                print(&#39;Stopping thread...&#39;)
                break

        except SystemExit as e: # thrown whenever parser doesn&#39;t like input
            # print(&#39;Bad command:&#39;, e)
            continue
        except TypeError as e:  # probably from bad command args, eg. &gt;&gt;&gt; help something
            print(&#39;Bad command extra args:&#39;, e)
            continue
        # thrown when ctrl-c interrupts hanging input() -
        # except (KeyboardInterrupt, EOFError, Exception) as e:
        #     break

    self.onshutdown()</code></pre>
</details>
</dd>
<dt id="livemelee.interact.LiveInputsThread.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"><p>Override this if you want to check something each frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, gamestate):
    &#39;&#39;&#39;Override this if you want to check something each frame.&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livemelee" href="index.html">livemelee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livemelee.interact.LiveGameStats" href="#livemelee.interact.LiveGameStats">LiveGameStats</a></code></h4>
<ul class="">
<li><code><a title="livemelee.interact.LiveGameStats.update" href="#livemelee.interact.LiveGameStats.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livemelee.interact.LiveInputsThread" href="#livemelee.interact.LiveInputsThread">LiveInputsThread</a></code></h4>
<ul class="">
<li><code><a title="livemelee.interact.LiveInputsThread.run" href="#livemelee.interact.LiveInputsThread.run">run</a></code></li>
<li><code><a title="livemelee.interact.LiveInputsThread.update" href="#livemelee.interact.LiveInputsThread.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>