<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>livemelee.bots API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>livemelee.bots</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import melee
import random
import time
from . import Inputs
from . import Stat

Buttons = melee.enums.Button
Actions = melee.enums.Action

class Bot:
    &#39;&#39;&#39;Framework for making controller inputs.
    Offline only implementation currently.

    Attributes:
        controller: melee.Controller
        character: melee.Character
        stage: melee.Stage&#39;&#39;&#39;

    def __init__(self, controller=None,
                 character=melee.Character.FOX,
                 stage=melee.Stage.FINAL_DESTINATION):
        self.controller = controller
        self.character = character
        self.stage = stage

    def act(self, gamestate):
        &#39;&#39;&#39;Main function called each frame of game loop with updated gamestate.&#39;&#39;&#39;

        # if gamestate.menu_state in (melee.Menu.IN_GAME,
        #                             melee.Menu.SUDDEN_DEATH):
        if Stat.in_game(gamestate):
            self.play_frame(gamestate)  # rand note, paused wont advance frame
        else:
            self.menu_nav(gamestate)

    def menu_nav(self, gamestate):
        &#39;&#39;&#39;Processes menus with given character, stage.&#39;&#39;&#39;
        melee.MenuHelper.menu_helper_simple(gamestate,
                                            self.controller,
                                            self.character,
                                            self.stage,
                                            &#39;&#39;, # connect code
                                            0,  # cpu_level (0 for N/A)
                                            0,  # costume
                                            autostart=True)

    def play_frame(self, gamestate):
        &#39;&#39;&#39;Bot game logic implemented here.&#39;&#39;&#39;
        pass

def always(gamestate):
    return True

def never(gamestate):
    return False

class InputsBot(Bot):
    &#39;&#39;&#39;Adds inputs queue to Bot.

    Inputs should be always put into queue,
    never called directly/instantly with controller.
    First queued input will happen same frame of queueing.

    Attributes:
        queue: list of inputs as outlined in inputs.py&#39;&#39;&#39;

    def __init__(self, controller, character, stage):
        super().__init__(controller, character, stage)
        self.queue = []

    def play_frame(self, gamestate):
        self.check_frame(gamestate)
        self.consume_next_inputs()

    def consume_next_inputs(self):
        &#39;&#39;&#39;Called each frame to press or release next buttons in queue.
        See inputs.py for expected inputs format.&#39;&#39;&#39;
        if self.queue:
            inputs = self.queue.pop(0)
            Inputs.make_inputs(inputs, self.controller)

    def perform(self, input_sequence):
        &#39;&#39;&#39;Set queue to a sequence of inputs.
        Useful in lambdas where assignment is not allowed.&#39;&#39;&#39;
        self.queue = list(input_sequence)  # need a (deep) copy for modifiable lists/tuples

    def check_frame(self, gamestate):
        &#39;&#39;&#39;Override this (instead of overriding play_frame).
        Decision making and input queueing happen here.&#39;&#39;&#39;
        pass

class CheckBot(InputsBot):
    &#39;&#39;&#39;Adds condition checker to main loop.

    Attributes:
        when: (ie trigger) condition called every frame (func taking gamestate)

        do: (ie on_trigger) func called when condition returns True

    By default, stops checking upon reaching condition.
    `set_timer()` is an example of using `when` and `do`.

    Eg.
    `self.repeat(when=self.finished_inputs, do=some_func)`&#39;&#39;&#39;

    def __init__(self, controller=None,
                 character=melee.Character.FOX,
                 stage=melee.Stage.FINAL_DESTINATION):
        super().__init__(controller=controller,
                         character=character,
                         stage=stage)

        self.when = never
        self.do = lambda:None
        self._max_time = 30  # arbitrary init
        self._timer = self._max_time

    def check_frame(self, gamestate):
        &#39;&#39;&#39;Called each frame to check gamestate (and/or possibly self?) for condition,
        stopping check when True.&#39;&#39;&#39;
        if self.when(gamestate):
            self.when = never
            self.do()

    def set_timer(self, n, do, repeat=True):
        &#39;&#39;&#39;Set all required timer functions:
        n frames to wait, timer condition, callback.&#39;&#39;&#39;
        self._max_time = n
        self._timer = self._max_time
        if repeat:
            self.repeat(when=self._times_up,
                        do=do)
        else:
            self.when = self._times_up
            self.do = do

    def _times_up(self, gamestate):
        &#39;&#39;&#39;A condition check that ticks timer, returning True on expire.&#39;&#39;&#39;
        if self._timer &gt; 0:
            self._timer -= 1
            return False
        else:
            self._timer = self._max_time
            return True

    def repeat(self, when, do):
        &#39;&#39;&#39;Keeps checking when condition (as opposed to the default stop checking).&#39;&#39;&#39;
        def do_and_wait_again():
            do()
            self.when = when
        self.when = when
        self.do = do_and_wait_again

    def finished_inputs(self, gamestate):
        &#39;&#39;&#39;A condition to loop inputs by returning True when queue is empty.

        Eg.
        ```
        self.when = self.finished_inputs
        self.do = something
        ```&#39;&#39;&#39;
        return len(self.queue) == 0

class ControllableBot(InputsBot):
    &#39;&#39;&#39;Designed to easily control externally in real time,
    eg. from live thread or perhaps something like a chat.

    Attributes:
        commands: dict of `{&#39;cmd&#39;: (func, &#39;description&#39;)}`
            See LiveInputsThread for details.&#39;&#39;&#39;

    def __init__(self, controller=None,
                 character=melee.Character.FALCO,
                 stage=melee.Stage.FINAL_DESTINATION):
        super().__init__(controller, character, stage)

        self.commands = self._init_commands()
        self._curr_sequence = []

    def _init_commands(self):

        commands = {cmd: self._set_seq(make_seq) for cmd, make_seq in {
            &#39;laser&#39;: Inputs.laser,
            &#39;sh&#39;: Inputs.shorthop,
            &#39;shlaser&#39;: Inputs.jump_n_laser,  #fastfall_laser_rand
            &#39;taunt&#39;: Inputs.taunt,
            &#39;shield&#39;: Inputs.shield,
            &#39;dd&#39;: Inputs.dashdance,
        }.items()}
        commands.update({cmd: self._set_seq(_make_seq(btn)) for cmd, btn in {
            &#39;release&#39;: Inputs.release,
            &#39;center&#39;: Inputs.center,
            &#39;down&#39;: Inputs.down,
            &#39;up&#39;: Inputs.up,
            &#39;left&#39;: Inputs.left,
            &#39;right&#39;: Inputs.right,
            &#39;A&#39;: Inputs.A,
            &#39;B&#39;: Inputs.B,
            &#39;Y&#39;: Inputs.Y,
            &#39;L&#39;: Inputs.L
        }.items()})
        # commands.update({
        #     &#39;undo&#39;: self.release_last,
        # })
        return commands

    def _set_seq(self, make_seq):
        # wrapper to set current sequence to result of sequence maker func
        return lambda: self.set_curr_seq(make_seq())

    def set_curr_seq(self, inputs):
        self._curr_sequence = inputs# [(Inputs.release,), *inputs]

    def add_to_queue(self, inputs):
        # add to any existing inputs (usually would replace them)
        self.queue.extend(inputs)

    def check_frame(self, gamestate):
        # keep doing current sequence, looping if finished

        if len(self.queue) == 0:
            self.perform(self._curr_sequence)
        # if self.timer == 0:
        #     self.queue = Inputs.laser

def _make_seq(button):
    # wrapper to put single button press into a sequence
    return lambda: [(button,),]

class FalcoBot(CheckBot):
    # working with previous features

    def __init__(self, controller=None):
        super().__init__(controller=controller,
                         character=melee.Character.FALCO,
                         stage=melee.Stage.FINAL_DESTINATION)

        # self.investigate_jumpframes()
        self.jumped = False
        self.set_shorthop_laser_strat()

    def set_standing_laser_strat(self):
        self.set_timer(2, lambda: self.perform(Inputs.laser()), repeat=True)
        # self.repeat(when=self.finished_inputs,
        #             do=lambda: self.perform(laser))

    def set_shorthop_laser_strat(self):
        self.jumped = False
        self.repeat(when=self.can_jump,
                    do=self.sh_laser)

    def set_jump_strat(self):
        self.jumped = False
        self.repeat(when=self.can_jump,
                    do=self.jump)

    def can_jump(self, gamestate):
        if Stat.grounded(gamestate):
            if self.jumped:
                return False
            else:
                return True
        else:
            self.jumped = False # safe to reset now
            return False

    def sh_laser(self):
        self.perform([*Inputs.wait(3), *Inputs.fastfall_laser_rand()])
        self.jumped = True

    def jump(self):
        self.perform([*Inputs.wait(3), *Inputs.shorthop()])
        self.jumped = True

    ### example of finding out frame data

    def investigate_jumpframes(self):
        self.prepause = 0
        self.jumped = False
        self.max_time = 45

        def timer_checking_jump(gamestate):
            if self.timer &lt; 0:
                # print(&#39;timer up&#39;)
                title = &#39;prepause {} f,&#39;.format(self.prepause)
                if self.jumped:
                    print(title, &#39;success&#39;)
                    # self.when = never
                    # return True
                else:
                    print(title, &#39;fail&#39;)
                # reset everything and inc pause frames
                self.timer = self.max_time
                self.prepause += 1
                self.jumped = False
                return True
            else:
                self.timer -= 1
                if not Stat.grounded(gamestate):
                    self.jumped = True  # should be success but just let timer tick
            return False

        self.repeat(when=timer_checking_jump,
                    do=self.jump_with_wait)

    def jump_with_wait(self):
        self.perform([*Inputs.wait(self.prepause), *Inputs.shorthop()])

    ### toxic demos, use responsibly

    def taunt(self):
        # interrupt activities to taunt asap.
        # keeps setting queue until taunting actually happens

        # self.last_when = self.when
        self.when = Stat.not_taunting
        self.do = lambda: self.perform([(Inputs.release,), *Inputs.taunt()])

    def ragequit(self): #, angry_misinput=True):
        # special pause case: frames not advanced in pause, so we have to
        # independently execute multiple presses outside of main loop.
        # generally poor use of inputs and lack of queue.
        inputs = [
            (True, Buttons.BUTTON_START),
            (True, Buttons.BUTTON_L),
            (True, Buttons.BUTTON_R),
            (True, Buttons.BUTTON_A),
        ]
        self.controller.release_all()
        for press, *button_args in inputs:
            self.controller.press_button(*button_args)
            time.sleep(0.01) # could be needed if incosistent timing?

# under construction:

# class MultiCheckBot(InputsBot):
#
#     FINISH_NOW = 1
#     STOP_CHECKING = 2
#     KEEP_CHECKING = 3
#
#     def __init__(self, controller,
#                  character=melee.Character.FALCO,
#                  stage=melee.Stage.FINAL_DESTINATION):
#         super().__init__(controller, character, stage)
#
#         self.checks = {}
#
#     def check_frame(self, gamestate):
#         remove = []
#         for condition, do in self.checks.items():
#             if condition(self, gamestate):
#                 retval = do()
#                 if retval == MultiCheckBot.FINISH_NOW:
#                     return
#                 elif retval == MultiCheckBot.STOP_CHECKING:
#                     remove.append(condition)
#         for condition in remove:
#             del self.checks[condition]
#
#     def something(self):
#         pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="livemelee.bots.always"><code class="name flex">
<span>def <span class="ident">always</span></span>(<span>gamestate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def always(gamestate):
    return True</code></pre>
</details>
</dd>
<dt id="livemelee.bots.never"><code class="name flex">
<span>def <span class="ident">never</span></span>(<span>gamestate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def never(gamestate):
    return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="livemelee.bots.Bot"><code class="flex name class">
<span>class <span class="ident">Bot</span></span>
<span>(</span><span>controller=None, character=Character.FOX, stage=Stage.FINAL_DESTINATION)</span>
</code></dt>
<dd>
<div class="desc"><p>Framework for making controller inputs.
Offline only implementation currently.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>controller</code></strong></dt>
<dd>melee.Controller</dd>
<dt><strong><code>character</code></strong></dt>
<dd>melee.Character</dd>
<dt><strong><code>stage</code></strong></dt>
<dd>melee.Stage</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bot:
    &#39;&#39;&#39;Framework for making controller inputs.
    Offline only implementation currently.

    Attributes:
        controller: melee.Controller
        character: melee.Character
        stage: melee.Stage&#39;&#39;&#39;

    def __init__(self, controller=None,
                 character=melee.Character.FOX,
                 stage=melee.Stage.FINAL_DESTINATION):
        self.controller = controller
        self.character = character
        self.stage = stage

    def act(self, gamestate):
        &#39;&#39;&#39;Main function called each frame of game loop with updated gamestate.&#39;&#39;&#39;

        # if gamestate.menu_state in (melee.Menu.IN_GAME,
        #                             melee.Menu.SUDDEN_DEATH):
        if Stat.in_game(gamestate):
            self.play_frame(gamestate)  # rand note, paused wont advance frame
        else:
            self.menu_nav(gamestate)

    def menu_nav(self, gamestate):
        &#39;&#39;&#39;Processes menus with given character, stage.&#39;&#39;&#39;
        melee.MenuHelper.menu_helper_simple(gamestate,
                                            self.controller,
                                            self.character,
                                            self.stage,
                                            &#39;&#39;, # connect code
                                            0,  # cpu_level (0 for N/A)
                                            0,  # costume
                                            autostart=True)

    def play_frame(self, gamestate):
        &#39;&#39;&#39;Bot game logic implemented here.&#39;&#39;&#39;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livemelee.bots.InputsBot" href="#livemelee.bots.InputsBot">InputsBot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livemelee.bots.Bot.act"><code class="name flex">
<span>def <span class="ident">act</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function called each frame of game loop with updated gamestate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def act(self, gamestate):
    &#39;&#39;&#39;Main function called each frame of game loop with updated gamestate.&#39;&#39;&#39;

    # if gamestate.menu_state in (melee.Menu.IN_GAME,
    #                             melee.Menu.SUDDEN_DEATH):
    if Stat.in_game(gamestate):
        self.play_frame(gamestate)  # rand note, paused wont advance frame
    else:
        self.menu_nav(gamestate)</code></pre>
</details>
</dd>
<dt id="livemelee.bots.Bot.menu_nav"><code class="name flex">
<span>def <span class="ident">menu_nav</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes menus with given character, stage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def menu_nav(self, gamestate):
    &#39;&#39;&#39;Processes menus with given character, stage.&#39;&#39;&#39;
    melee.MenuHelper.menu_helper_simple(gamestate,
                                        self.controller,
                                        self.character,
                                        self.stage,
                                        &#39;&#39;, # connect code
                                        0,  # cpu_level (0 for N/A)
                                        0,  # costume
                                        autostart=True)</code></pre>
</details>
</dd>
<dt id="livemelee.bots.Bot.play_frame"><code class="name flex">
<span>def <span class="ident">play_frame</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"><p>Bot game logic implemented here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play_frame(self, gamestate):
    &#39;&#39;&#39;Bot game logic implemented here.&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="livemelee.bots.CheckBot"><code class="flex name class">
<span>class <span class="ident">CheckBot</span></span>
<span>(</span><span>controller=None, character=Character.FOX, stage=Stage.FINAL_DESTINATION)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds condition checker to main loop.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>when</code></strong></dt>
<dd>(ie trigger) condition called every frame (func taking gamestate)</dd>
<dt><strong><code>do</code></strong></dt>
<dd>(ie on_trigger) func called when condition returns True</dd>
</dl>
<p>By default, stops checking upon reaching condition.
<code>set_timer()</code> is an example of using <code>when</code> and <code>do</code>.</p>
<p>Eg.
<code>self.repeat(when=self.finished_inputs, do=some_func)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckBot(InputsBot):
    &#39;&#39;&#39;Adds condition checker to main loop.

    Attributes:
        when: (ie trigger) condition called every frame (func taking gamestate)

        do: (ie on_trigger) func called when condition returns True

    By default, stops checking upon reaching condition.
    `set_timer()` is an example of using `when` and `do`.

    Eg.
    `self.repeat(when=self.finished_inputs, do=some_func)`&#39;&#39;&#39;

    def __init__(self, controller=None,
                 character=melee.Character.FOX,
                 stage=melee.Stage.FINAL_DESTINATION):
        super().__init__(controller=controller,
                         character=character,
                         stage=stage)

        self.when = never
        self.do = lambda:None
        self._max_time = 30  # arbitrary init
        self._timer = self._max_time

    def check_frame(self, gamestate):
        &#39;&#39;&#39;Called each frame to check gamestate (and/or possibly self?) for condition,
        stopping check when True.&#39;&#39;&#39;
        if self.when(gamestate):
            self.when = never
            self.do()

    def set_timer(self, n, do, repeat=True):
        &#39;&#39;&#39;Set all required timer functions:
        n frames to wait, timer condition, callback.&#39;&#39;&#39;
        self._max_time = n
        self._timer = self._max_time
        if repeat:
            self.repeat(when=self._times_up,
                        do=do)
        else:
            self.when = self._times_up
            self.do = do

    def _times_up(self, gamestate):
        &#39;&#39;&#39;A condition check that ticks timer, returning True on expire.&#39;&#39;&#39;
        if self._timer &gt; 0:
            self._timer -= 1
            return False
        else:
            self._timer = self._max_time
            return True

    def repeat(self, when, do):
        &#39;&#39;&#39;Keeps checking when condition (as opposed to the default stop checking).&#39;&#39;&#39;
        def do_and_wait_again():
            do()
            self.when = when
        self.when = when
        self.do = do_and_wait_again

    def finished_inputs(self, gamestate):
        &#39;&#39;&#39;A condition to loop inputs by returning True when queue is empty.

        Eg.
        ```
        self.when = self.finished_inputs
        self.do = something
        ```&#39;&#39;&#39;
        return len(self.queue) == 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livemelee.bots.InputsBot" href="#livemelee.bots.InputsBot">InputsBot</a></li>
<li><a title="livemelee.bots.Bot" href="#livemelee.bots.Bot">Bot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livemelee.bots.FalcoBot" href="#livemelee.bots.FalcoBot">FalcoBot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livemelee.bots.CheckBot.check_frame"><code class="name flex">
<span>def <span class="ident">check_frame</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"><p>Called each frame to check gamestate (and/or possibly self?) for condition,
stopping check when True.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_frame(self, gamestate):
    &#39;&#39;&#39;Called each frame to check gamestate (and/or possibly self?) for condition,
    stopping check when True.&#39;&#39;&#39;
    if self.when(gamestate):
        self.when = never
        self.do()</code></pre>
</details>
</dd>
<dt id="livemelee.bots.CheckBot.finished_inputs"><code class="name flex">
<span>def <span class="ident">finished_inputs</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"><p>A condition to loop inputs by returning True when queue is empty.</p>
<p>Eg.</p>
<pre><code>self.when = self.finished_inputs
self.do = something
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finished_inputs(self, gamestate):
    &#39;&#39;&#39;A condition to loop inputs by returning True when queue is empty.

    Eg.
    ```
    self.when = self.finished_inputs
    self.do = something
    ```&#39;&#39;&#39;
    return len(self.queue) == 0</code></pre>
</details>
</dd>
<dt id="livemelee.bots.CheckBot.repeat"><code class="name flex">
<span>def <span class="ident">repeat</span></span>(<span>self, when, do)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps checking when condition (as opposed to the default stop checking).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(self, when, do):
    &#39;&#39;&#39;Keeps checking when condition (as opposed to the default stop checking).&#39;&#39;&#39;
    def do_and_wait_again():
        do()
        self.when = when
    self.when = when
    self.do = do_and_wait_again</code></pre>
</details>
</dd>
<dt id="livemelee.bots.CheckBot.set_timer"><code class="name flex">
<span>def <span class="ident">set_timer</span></span>(<span>self, n, do, repeat=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all required timer functions:
n frames to wait, timer condition, callback.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_timer(self, n, do, repeat=True):
    &#39;&#39;&#39;Set all required timer functions:
    n frames to wait, timer condition, callback.&#39;&#39;&#39;
    self._max_time = n
    self._timer = self._max_time
    if repeat:
        self.repeat(when=self._times_up,
                    do=do)
    else:
        self.when = self._times_up
        self.do = do</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livemelee.bots.InputsBot" href="#livemelee.bots.InputsBot">InputsBot</a></b></code>:
<ul class="hlist">
<li><code><a title="livemelee.bots.InputsBot.act" href="#livemelee.bots.Bot.act">act</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.consume_next_inputs" href="#livemelee.bots.InputsBot.consume_next_inputs">consume_next_inputs</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.menu_nav" href="#livemelee.bots.Bot.menu_nav">menu_nav</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.perform" href="#livemelee.bots.InputsBot.perform">perform</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.play_frame" href="#livemelee.bots.Bot.play_frame">play_frame</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livemelee.bots.ControllableBot"><code class="flex name class">
<span>class <span class="ident">ControllableBot</span></span>
<span>(</span><span>controller=None, character=Character.FALCO, stage=Stage.FINAL_DESTINATION)</span>
</code></dt>
<dd>
<div class="desc"><p>Designed to easily control externally in real time,
eg. from live thread or perhaps something like a chat.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>commands</code></strong></dt>
<dd>dict of <code>{'cmd': (func, 'description')}</code>
See LiveInputsThread for details.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ControllableBot(InputsBot):
    &#39;&#39;&#39;Designed to easily control externally in real time,
    eg. from live thread or perhaps something like a chat.

    Attributes:
        commands: dict of `{&#39;cmd&#39;: (func, &#39;description&#39;)}`
            See LiveInputsThread for details.&#39;&#39;&#39;

    def __init__(self, controller=None,
                 character=melee.Character.FALCO,
                 stage=melee.Stage.FINAL_DESTINATION):
        super().__init__(controller, character, stage)

        self.commands = self._init_commands()
        self._curr_sequence = []

    def _init_commands(self):

        commands = {cmd: self._set_seq(make_seq) for cmd, make_seq in {
            &#39;laser&#39;: Inputs.laser,
            &#39;sh&#39;: Inputs.shorthop,
            &#39;shlaser&#39;: Inputs.jump_n_laser,  #fastfall_laser_rand
            &#39;taunt&#39;: Inputs.taunt,
            &#39;shield&#39;: Inputs.shield,
            &#39;dd&#39;: Inputs.dashdance,
        }.items()}
        commands.update({cmd: self._set_seq(_make_seq(btn)) for cmd, btn in {
            &#39;release&#39;: Inputs.release,
            &#39;center&#39;: Inputs.center,
            &#39;down&#39;: Inputs.down,
            &#39;up&#39;: Inputs.up,
            &#39;left&#39;: Inputs.left,
            &#39;right&#39;: Inputs.right,
            &#39;A&#39;: Inputs.A,
            &#39;B&#39;: Inputs.B,
            &#39;Y&#39;: Inputs.Y,
            &#39;L&#39;: Inputs.L
        }.items()})
        # commands.update({
        #     &#39;undo&#39;: self.release_last,
        # })
        return commands

    def _set_seq(self, make_seq):
        # wrapper to set current sequence to result of sequence maker func
        return lambda: self.set_curr_seq(make_seq())

    def set_curr_seq(self, inputs):
        self._curr_sequence = inputs# [(Inputs.release,), *inputs]

    def add_to_queue(self, inputs):
        # add to any existing inputs (usually would replace them)
        self.queue.extend(inputs)

    def check_frame(self, gamestate):
        # keep doing current sequence, looping if finished

        if len(self.queue) == 0:
            self.perform(self._curr_sequence)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livemelee.bots.InputsBot" href="#livemelee.bots.InputsBot">InputsBot</a></li>
<li><a title="livemelee.bots.Bot" href="#livemelee.bots.Bot">Bot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livemelee.bots.ControllableBot.add_to_queue"><code class="name flex">
<span>def <span class="ident">add_to_queue</span></span>(<span>self, inputs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_queue(self, inputs):
    # add to any existing inputs (usually would replace them)
    self.queue.extend(inputs)</code></pre>
</details>
</dd>
<dt id="livemelee.bots.ControllableBot.set_curr_seq"><code class="name flex">
<span>def <span class="ident">set_curr_seq</span></span>(<span>self, inputs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_curr_seq(self, inputs):
    self._curr_sequence = inputs# [(Inputs.release,), *inputs]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livemelee.bots.InputsBot" href="#livemelee.bots.InputsBot">InputsBot</a></b></code>:
<ul class="hlist">
<li><code><a title="livemelee.bots.InputsBot.act" href="#livemelee.bots.Bot.act">act</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.check_frame" href="#livemelee.bots.InputsBot.check_frame">check_frame</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.consume_next_inputs" href="#livemelee.bots.InputsBot.consume_next_inputs">consume_next_inputs</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.menu_nav" href="#livemelee.bots.Bot.menu_nav">menu_nav</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.perform" href="#livemelee.bots.InputsBot.perform">perform</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.play_frame" href="#livemelee.bots.Bot.play_frame">play_frame</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livemelee.bots.FalcoBot"><code class="flex name class">
<span>class <span class="ident">FalcoBot</span></span>
<span>(</span><span>controller=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds condition checker to main loop.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>when</code></strong></dt>
<dd>(ie trigger) condition called every frame (func taking gamestate)</dd>
<dt><strong><code>do</code></strong></dt>
<dd>(ie on_trigger) func called when condition returns True</dd>
</dl>
<p>By default, stops checking upon reaching condition.
<code>set_timer()</code> is an example of using <code>when</code> and <code>do</code>.</p>
<p>Eg.
<code>self.repeat(when=self.finished_inputs, do=some_func)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FalcoBot(CheckBot):
    # working with previous features

    def __init__(self, controller=None):
        super().__init__(controller=controller,
                         character=melee.Character.FALCO,
                         stage=melee.Stage.FINAL_DESTINATION)

        # self.investigate_jumpframes()
        self.jumped = False
        self.set_shorthop_laser_strat()

    def set_standing_laser_strat(self):
        self.set_timer(2, lambda: self.perform(Inputs.laser()), repeat=True)
        # self.repeat(when=self.finished_inputs,
        #             do=lambda: self.perform(laser))

    def set_shorthop_laser_strat(self):
        self.jumped = False
        self.repeat(when=self.can_jump,
                    do=self.sh_laser)

    def set_jump_strat(self):
        self.jumped = False
        self.repeat(when=self.can_jump,
                    do=self.jump)

    def can_jump(self, gamestate):
        if Stat.grounded(gamestate):
            if self.jumped:
                return False
            else:
                return True
        else:
            self.jumped = False # safe to reset now
            return False

    def sh_laser(self):
        self.perform([*Inputs.wait(3), *Inputs.fastfall_laser_rand()])
        self.jumped = True

    def jump(self):
        self.perform([*Inputs.wait(3), *Inputs.shorthop()])
        self.jumped = True

    ### example of finding out frame data

    def investigate_jumpframes(self):
        self.prepause = 0
        self.jumped = False
        self.max_time = 45

        def timer_checking_jump(gamestate):
            if self.timer &lt; 0:
                # print(&#39;timer up&#39;)
                title = &#39;prepause {} f,&#39;.format(self.prepause)
                if self.jumped:
                    print(title, &#39;success&#39;)
                    # self.when = never
                    # return True
                else:
                    print(title, &#39;fail&#39;)
                # reset everything and inc pause frames
                self.timer = self.max_time
                self.prepause += 1
                self.jumped = False
                return True
            else:
                self.timer -= 1
                if not Stat.grounded(gamestate):
                    self.jumped = True  # should be success but just let timer tick
            return False

        self.repeat(when=timer_checking_jump,
                    do=self.jump_with_wait)

    def jump_with_wait(self):
        self.perform([*Inputs.wait(self.prepause), *Inputs.shorthop()])

    ### toxic demos, use responsibly

    def taunt(self):
        # interrupt activities to taunt asap.
        # keeps setting queue until taunting actually happens

        # self.last_when = self.when
        self.when = Stat.not_taunting
        self.do = lambda: self.perform([(Inputs.release,), *Inputs.taunt()])

    def ragequit(self): #, angry_misinput=True):
        # special pause case: frames not advanced in pause, so we have to
        # independently execute multiple presses outside of main loop.
        # generally poor use of inputs and lack of queue.
        inputs = [
            (True, Buttons.BUTTON_START),
            (True, Buttons.BUTTON_L),
            (True, Buttons.BUTTON_R),
            (True, Buttons.BUTTON_A),
        ]
        self.controller.release_all()
        for press, *button_args in inputs:
            self.controller.press_button(*button_args)
            time.sleep(0.01) # could be needed if incosistent timing?</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livemelee.bots.CheckBot" href="#livemelee.bots.CheckBot">CheckBot</a></li>
<li><a title="livemelee.bots.InputsBot" href="#livemelee.bots.InputsBot">InputsBot</a></li>
<li><a title="livemelee.bots.Bot" href="#livemelee.bots.Bot">Bot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livemelee.bots.FalcoBot.can_jump"><code class="name flex">
<span>def <span class="ident">can_jump</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_jump(self, gamestate):
    if Stat.grounded(gamestate):
        if self.jumped:
            return False
        else:
            return True
    else:
        self.jumped = False # safe to reset now
        return False</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.investigate_jumpframes"><code class="name flex">
<span>def <span class="ident">investigate_jumpframes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def investigate_jumpframes(self):
    self.prepause = 0
    self.jumped = False
    self.max_time = 45

    def timer_checking_jump(gamestate):
        if self.timer &lt; 0:
            # print(&#39;timer up&#39;)
            title = &#39;prepause {} f,&#39;.format(self.prepause)
            if self.jumped:
                print(title, &#39;success&#39;)
                # self.when = never
                # return True
            else:
                print(title, &#39;fail&#39;)
            # reset everything and inc pause frames
            self.timer = self.max_time
            self.prepause += 1
            self.jumped = False
            return True
        else:
            self.timer -= 1
            if not Stat.grounded(gamestate):
                self.jumped = True  # should be success but just let timer tick
        return False

    self.repeat(when=timer_checking_jump,
                do=self.jump_with_wait)</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.jump"><code class="name flex">
<span>def <span class="ident">jump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jump(self):
    self.perform([*Inputs.wait(3), *Inputs.shorthop()])
    self.jumped = True</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.jump_with_wait"><code class="name flex">
<span>def <span class="ident">jump_with_wait</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jump_with_wait(self):
    self.perform([*Inputs.wait(self.prepause), *Inputs.shorthop()])</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.ragequit"><code class="name flex">
<span>def <span class="ident">ragequit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ragequit(self): #, angry_misinput=True):
    # special pause case: frames not advanced in pause, so we have to
    # independently execute multiple presses outside of main loop.
    # generally poor use of inputs and lack of queue.
    inputs = [
        (True, Buttons.BUTTON_START),
        (True, Buttons.BUTTON_L),
        (True, Buttons.BUTTON_R),
        (True, Buttons.BUTTON_A),
    ]
    self.controller.release_all()
    for press, *button_args in inputs:
        self.controller.press_button(*button_args)
        time.sleep(0.01) # could be needed if incosistent timing?</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.set_jump_strat"><code class="name flex">
<span>def <span class="ident">set_jump_strat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_jump_strat(self):
    self.jumped = False
    self.repeat(when=self.can_jump,
                do=self.jump)</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.set_shorthop_laser_strat"><code class="name flex">
<span>def <span class="ident">set_shorthop_laser_strat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_shorthop_laser_strat(self):
    self.jumped = False
    self.repeat(when=self.can_jump,
                do=self.sh_laser)</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.set_standing_laser_strat"><code class="name flex">
<span>def <span class="ident">set_standing_laser_strat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_standing_laser_strat(self):
    self.set_timer(2, lambda: self.perform(Inputs.laser()), repeat=True)</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.sh_laser"><code class="name flex">
<span>def <span class="ident">sh_laser</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sh_laser(self):
    self.perform([*Inputs.wait(3), *Inputs.fastfall_laser_rand()])
    self.jumped = True</code></pre>
</details>
</dd>
<dt id="livemelee.bots.FalcoBot.taunt"><code class="name flex">
<span>def <span class="ident">taunt</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def taunt(self):
    # interrupt activities to taunt asap.
    # keeps setting queue until taunting actually happens

    # self.last_when = self.when
    self.when = Stat.not_taunting
    self.do = lambda: self.perform([(Inputs.release,), *Inputs.taunt()])</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livemelee.bots.CheckBot" href="#livemelee.bots.CheckBot">CheckBot</a></b></code>:
<ul class="hlist">
<li><code><a title="livemelee.bots.CheckBot.act" href="#livemelee.bots.Bot.act">act</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.check_frame" href="#livemelee.bots.CheckBot.check_frame">check_frame</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.consume_next_inputs" href="#livemelee.bots.InputsBot.consume_next_inputs">consume_next_inputs</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.finished_inputs" href="#livemelee.bots.CheckBot.finished_inputs">finished_inputs</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.menu_nav" href="#livemelee.bots.Bot.menu_nav">menu_nav</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.perform" href="#livemelee.bots.InputsBot.perform">perform</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.play_frame" href="#livemelee.bots.Bot.play_frame">play_frame</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.repeat" href="#livemelee.bots.CheckBot.repeat">repeat</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.set_timer" href="#livemelee.bots.CheckBot.set_timer">set_timer</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="livemelee.bots.InputsBot"><code class="flex name class">
<span>class <span class="ident">InputsBot</span></span>
<span>(</span><span>controller, character, stage)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds inputs queue to Bot.</p>
<p>Inputs should be always put into queue,
never called directly/instantly with controller.
First queued input will happen same frame of queueing.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>queue</code></strong></dt>
<dd>list of inputs as outlined in inputs.py</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InputsBot(Bot):
    &#39;&#39;&#39;Adds inputs queue to Bot.

    Inputs should be always put into queue,
    never called directly/instantly with controller.
    First queued input will happen same frame of queueing.

    Attributes:
        queue: list of inputs as outlined in inputs.py&#39;&#39;&#39;

    def __init__(self, controller, character, stage):
        super().__init__(controller, character, stage)
        self.queue = []

    def play_frame(self, gamestate):
        self.check_frame(gamestate)
        self.consume_next_inputs()

    def consume_next_inputs(self):
        &#39;&#39;&#39;Called each frame to press or release next buttons in queue.
        See inputs.py for expected inputs format.&#39;&#39;&#39;
        if self.queue:
            inputs = self.queue.pop(0)
            Inputs.make_inputs(inputs, self.controller)

    def perform(self, input_sequence):
        &#39;&#39;&#39;Set queue to a sequence of inputs.
        Useful in lambdas where assignment is not allowed.&#39;&#39;&#39;
        self.queue = list(input_sequence)  # need a (deep) copy for modifiable lists/tuples

    def check_frame(self, gamestate):
        &#39;&#39;&#39;Override this (instead of overriding play_frame).
        Decision making and input queueing happen here.&#39;&#39;&#39;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="livemelee.bots.Bot" href="#livemelee.bots.Bot">Bot</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="livemelee.bots.CheckBot" href="#livemelee.bots.CheckBot">CheckBot</a></li>
<li><a title="livemelee.bots.ControllableBot" href="#livemelee.bots.ControllableBot">ControllableBot</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="livemelee.bots.InputsBot.check_frame"><code class="name flex">
<span>def <span class="ident">check_frame</span></span>(<span>self, gamestate)</span>
</code></dt>
<dd>
<div class="desc"><p>Override this (instead of overriding play_frame).
Decision making and input queueing happen here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_frame(self, gamestate):
    &#39;&#39;&#39;Override this (instead of overriding play_frame).
    Decision making and input queueing happen here.&#39;&#39;&#39;
    pass</code></pre>
</details>
</dd>
<dt id="livemelee.bots.InputsBot.consume_next_inputs"><code class="name flex">
<span>def <span class="ident">consume_next_inputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called each frame to press or release next buttons in queue.
See inputs.py for expected inputs format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consume_next_inputs(self):
    &#39;&#39;&#39;Called each frame to press or release next buttons in queue.
    See inputs.py for expected inputs format.&#39;&#39;&#39;
    if self.queue:
        inputs = self.queue.pop(0)
        Inputs.make_inputs(inputs, self.controller)</code></pre>
</details>
</dd>
<dt id="livemelee.bots.InputsBot.perform"><code class="name flex">
<span>def <span class="ident">perform</span></span>(<span>self, input_sequence)</span>
</code></dt>
<dd>
<div class="desc"><p>Set queue to a sequence of inputs.
Useful in lambdas where assignment is not allowed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform(self, input_sequence):
    &#39;&#39;&#39;Set queue to a sequence of inputs.
    Useful in lambdas where assignment is not allowed.&#39;&#39;&#39;
    self.queue = list(input_sequence)  # need a (deep) copy for modifiable lists/tuples</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="livemelee.bots.Bot" href="#livemelee.bots.Bot">Bot</a></b></code>:
<ul class="hlist">
<li><code><a title="livemelee.bots.Bot.act" href="#livemelee.bots.Bot.act">act</a></code></li>
<li><code><a title="livemelee.bots.Bot.menu_nav" href="#livemelee.bots.Bot.menu_nav">menu_nav</a></code></li>
<li><code><a title="livemelee.bots.Bot.play_frame" href="#livemelee.bots.Bot.play_frame">play_frame</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="livemelee" href="index.html">livemelee</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="livemelee.bots.always" href="#livemelee.bots.always">always</a></code></li>
<li><code><a title="livemelee.bots.never" href="#livemelee.bots.never">never</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="livemelee.bots.Bot" href="#livemelee.bots.Bot">Bot</a></code></h4>
<ul class="">
<li><code><a title="livemelee.bots.Bot.act" href="#livemelee.bots.Bot.act">act</a></code></li>
<li><code><a title="livemelee.bots.Bot.menu_nav" href="#livemelee.bots.Bot.menu_nav">menu_nav</a></code></li>
<li><code><a title="livemelee.bots.Bot.play_frame" href="#livemelee.bots.Bot.play_frame">play_frame</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livemelee.bots.CheckBot" href="#livemelee.bots.CheckBot">CheckBot</a></code></h4>
<ul class="">
<li><code><a title="livemelee.bots.CheckBot.check_frame" href="#livemelee.bots.CheckBot.check_frame">check_frame</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.finished_inputs" href="#livemelee.bots.CheckBot.finished_inputs">finished_inputs</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.repeat" href="#livemelee.bots.CheckBot.repeat">repeat</a></code></li>
<li><code><a title="livemelee.bots.CheckBot.set_timer" href="#livemelee.bots.CheckBot.set_timer">set_timer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livemelee.bots.ControllableBot" href="#livemelee.bots.ControllableBot">ControllableBot</a></code></h4>
<ul class="">
<li><code><a title="livemelee.bots.ControllableBot.add_to_queue" href="#livemelee.bots.ControllableBot.add_to_queue">add_to_queue</a></code></li>
<li><code><a title="livemelee.bots.ControllableBot.set_curr_seq" href="#livemelee.bots.ControllableBot.set_curr_seq">set_curr_seq</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livemelee.bots.FalcoBot" href="#livemelee.bots.FalcoBot">FalcoBot</a></code></h4>
<ul class="">
<li><code><a title="livemelee.bots.FalcoBot.can_jump" href="#livemelee.bots.FalcoBot.can_jump">can_jump</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.investigate_jumpframes" href="#livemelee.bots.FalcoBot.investigate_jumpframes">investigate_jumpframes</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.jump" href="#livemelee.bots.FalcoBot.jump">jump</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.jump_with_wait" href="#livemelee.bots.FalcoBot.jump_with_wait">jump_with_wait</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.ragequit" href="#livemelee.bots.FalcoBot.ragequit">ragequit</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.set_jump_strat" href="#livemelee.bots.FalcoBot.set_jump_strat">set_jump_strat</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.set_shorthop_laser_strat" href="#livemelee.bots.FalcoBot.set_shorthop_laser_strat">set_shorthop_laser_strat</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.set_standing_laser_strat" href="#livemelee.bots.FalcoBot.set_standing_laser_strat">set_standing_laser_strat</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.sh_laser" href="#livemelee.bots.FalcoBot.sh_laser">sh_laser</a></code></li>
<li><code><a title="livemelee.bots.FalcoBot.taunt" href="#livemelee.bots.FalcoBot.taunt">taunt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="livemelee.bots.InputsBot" href="#livemelee.bots.InputsBot">InputsBot</a></code></h4>
<ul class="">
<li><code><a title="livemelee.bots.InputsBot.check_frame" href="#livemelee.bots.InputsBot.check_frame">check_frame</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.consume_next_inputs" href="#livemelee.bots.InputsBot.consume_next_inputs">consume_next_inputs</a></code></li>
<li><code><a title="livemelee.bots.InputsBot.perform" href="#livemelee.bots.InputsBot.perform">perform</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>